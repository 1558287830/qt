#!/bin/bash

die() {
    echo $*
    exit 1
}

default_tag="v8-snapshot-05042011"

if [ $# -eq 0 ]; then
    tag="$default_tag"
elif [ $# -eq 1 ]; then
    tag=$1
else
    die "usage: $0 [commit (defaults to $default_tag)]"
fi

repository=`git config v8.url`
if [ -z "$repository" ]; then
    die "error: cannot locate v8 git repository. please run git config --global v8.url /path-or-url/to/v8/repo"
fi

excluded_directories="$excluded_directories build benchmarks samples test .svn"


files_to_remove=""
files_to_remove="$files_to_remove .gitignore"
files_to_remove="$files_to_remove SConstruct"
files_to_remove="$files_to_remove src/SConscript"
files_to_remove="$files_to_remove *.svn*"
files_to_remove="$files_to_remove preparser/SConscript"
files_to_remove="$files_to_remove src/d8.gyp"

require_clean_work_tree() {
    # test if working tree is dirty
    git rev-parse --verify HEAD > /dev/null &&
    git update-index --refresh &&
    git diff-files --quiet &&
    git diff-index --cached --quiet HEAD ||
    die "Working tree is dirty"
}

which qmake >/dev/null 2>/dev/null
if [ "$?" != 0 ]; then
    die "abort: Could not locate qmake in your PATH"
fi

test -z "$(git rev-parse --show-cdup)" || {
       exit=$?
       echo >&2 "You need to run this command from the toplevel of the working tree."
       exit $exit
}

echo "checking working tree"
require_clean_work_tree

revCount=`git ls-remote $repository | grep $tag | awk '{print $1}' | wc -l`
if [ "$revCount" != 1 ]; then
    die "Cannot parse $tag into a revision. It seems ambiguous".
fi

rev=`git ls-remote $repository | grep -E "^.+$tag$" | awk '{print $1}'`

tarball=`mktemp /tmp/v8-snapshot.tar.XXXXXX` || exit 1
echo "creating $tarball"

echo "archiving v8 from $repository $tag ( $rev )"

git archive --remote=$repository $rev > $tarball || exit 1

echo "removing unwanted files and directories"
for dir in $excluded_directories; do
    echo "    removing $dir"
    tar --delete --file=$tarball $dir
done

for item in $exclude_with_exceptions_list; do
    dir=`echo $item | awk -F : '{print $1}'`
    include=`echo $item | awk -F : '{print $2}'`
    echo "    removing $dir except $include"
    files=`tar --list --file=$tarball $dir | grep -v -E "^$dir\$" | grep -v $include`
    tar --delete --file=$tarball $files
done

for file in $files_to_remove; do
    echo "    removing $file"
    tar --delete --wildcards --file=$tarball $file
done

echo "done!"

srcdir=src/3rdparty/v8
absSrcDir=$PWD/$srcdir
localDiff=
lastImportRevison=

echo "replacing $srcdir"
if [  -d $srcdir ]; then
    git ls-files $srcdir | xargs rm
    git ls-files -z src/3rdparty/v8 | git update-index --force-remove -z --stdin
else
    mkdir -p $srcdir
fi

(cd $srcdir && tar xf $tarball)
git add $srcdir

echo "generating extra sources"
#

cat >$srcdir/VERSION <<EOT
This is a snapshot of v8 from

        http://v8.googlecode.com/svn/branches/bleeding_edge

The commit imported was from the

        $tag branch/tag

and has the sha1 checksum

        $rev
EOT
git add $srcdir/VERSION

git diff-files --name-only -z | git update-index --remove -z --stdin

echo "removing $tarball"
rm -f $tarball

cat >commitlog.txt <<EOT
Updated v8 from $repository to $tag ( $rev )
EOT

echo "Changes:"
echo
git --no-pager diff --name-status --cached $srcdir

echo
echo "Wrote commitlog.txt. Use with"
echo
echo "    git commit -e -F commitlog.txt"
echo
echo "to commit your changes"
